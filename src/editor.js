define(['react', 'rope', 'build/react-wysiwyg', 'lexer'], function(React, rope, Editor, lexer) {
  var lexer = lexer.Lexer()
  var r = rope.Rope("// Copyright 2009 The Go Authors.  All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setmg_gcc)(void*, void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block),\n// as defined in /usr/src/lib/librthread/tcb.h\n#define TCB_SIZE (4 * sizeof(void *))\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n void *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n void *(*func)(void *);\n  void *arg;\n};\n\nstatic void\ntcb_fixup(int mainthread)\n{\n void *newtcb, *oldtcb;\n\n  // The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n // we need to allocate our own TLS space while preserving the existing\n  // TCB that has been setup via librthread.\n\n  newtcb = malloc(TCB_SIZE + TLS_SIZE);\n if(newtcb == NULL)\n    abort();\n\n  // The signal trampoline expects the TLS slots to be zeroed.\n  bzero(newtcb, TLS_SIZE);\n\n  oldtcb = __get_tcb();\n bcopy(oldtcb, newtcb + TLS_SIZE, TCB_SIZE);\n __set_tcb(newtcb + TLS_SIZE);\n\n // NOTE(jsing, minux): we can't free oldtcb without causing double-free\n // problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n  // has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n struct thread_args args = *(struct thread_args *)arg;\n\n free(arg);\n  tcb_fixup(0);\n\n return args.func(args.arg);\n}\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n  void *(*start_routine)(void *), void *arg)\n{\n struct thread_args *p;\n\n  p = malloc(sizeof(*p));\n if(p == NULL) {\n   errno = ENOMEM;\n   return -1;\n  }\n p->func = start_routine;\n  p->arg = arg;\n\n return sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setmg)(void*, void*))\n{\n  pthread_attr_t attr;\n  size_t size;\n  void *handle;\n\n setmg_gcc = setmg;\n  pthread_attr_init(&attr);\n pthread_attr_getstacksize(&attr, &size);\n  g->stackguard = (uintptr)&attr - size + 4096;\n pthread_attr_destroy(&attr);\n\n  // Locate symbol for the system pthread_create function.\n  handle = dlopen(\"libpthread.so\", RTLD_LAZY);\n  if(handle == NULL) {\n    fprintf(stderr, \"dlopen: failed to load libpthread: %s\n\", dlerror());\n    abort();\n  }\n sys_pthread_create = dlsym(handle, \"pthread_create\");\n if(sys_pthread_create == NULL) {\n    fprintf(stderr, \"dlsym: failed to find pthread_create: %s\n\", dlerror());\n   abort();\n  }\n dlclose(handle);\n\n  tcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n pthread_attr_t attr;\n  sigset_t ign, oset;\n pthread_t p;\n  size_t size;\n  int err;\n\n  sigfillset(&ign);\n sigprocmask(SIG_SETMASK, &ign, &oset);\n\n  pthread_attr_init(&attr);\n pthread_attr_getstacksize(&attr, &size);\n\n  ts->g->stackguard = size;\n err = sys_pthread_create(&p, &attr, threadentry, ts);\n\n sigprocmask(SIG_SETMASK, &oset, nil);\n\n if (err != 0) {\n   fprintf(stderr, \"runtime/cgo: pthread_create failed: %s\n\", strerror(err));\n   abort();\n  }\n}\n\nstatic void*\nthreadentry(void *v)\n{\n ThreadStart ts;\n\n tcb_fixup(0);\n\n ts = *(ThreadStart*)v;\n  free(v);\n\n  ts.g->stackbase = (uintptr)&ts;\n\n /*\n   * _cgo_sys_thread_start set stackguard to stack size;\n   * change to actual guard pointer.\n   */\n ts.g->stackguard = (uintptr)&ts - ts.g->stackguard + 4096;\n\n  /*\n   * Set specific keys.\n  */\n setmg_gcc((void*)ts.m, (void*)ts.g);\n\n  crosscall_amd64(ts.fn);\n return nil;\n}\n", lexer);

  var onChange = function(){
    
  }

  React.render(
    <Editor 
      linesVisible = {10}
      columnsVisible = {30}
      text = {r}
      onChange = {onChange}
    />, document.body
  );

});